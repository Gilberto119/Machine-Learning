# -*- coding: utf-8 -*-
"""No_Framework.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18kC43YRDSzZKRkdNvkdzDYuj-mf8H__v

Iris DataSet Machine Learning
"""

import pandas as pd
import numpy as np

# load the data
df = pd.read_csv('iris.csv')
df.head()

df = df.to_numpy()
df

"""Separacion del input con el output """

x, ty = df[:, 0:4], df[:, 5]
print (x.shape, ty.shape)

"""Creacion del diccionario para pasar de palabras a numeros"""

# diccionario de clases
classes = {'Iris-setosa': 0, 'Iris-versicolor': 1, 'Iris-virginica': 2}

# aplicar el diccionario a y
y = np.array([classes[i] for i in ty])
# transformar el one hot encoding
y_one = np.zeros((len(y), 3))
for i in range(len(y)):
    y_one[i, y[i]] = 1

print (y_one)

"""Definicion de funcion Sigmoid Logistica para conseguir la probabilida de un valor cambiando el rango de todos los valores reales a valores entre 0 y 1 """

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

"""Definicion de la clase modelo de regresion logistica que retorna la probabilidad de que un valor ingresado sea el valor esperado """

# definir el modelo
class Model:
    def __init__(self, x_shape, h_shape,y_shape):
        self.w1 = np.random.randn(x_shape, h_shape)
        self.b1 = np.random.randn(h_shape)
        self.w2 = np.random.randn(h_shape, y_shape)
        self.b2 = np.random.randn(y_shape)
        self.x_shape = x_shape
        self.y_shape = y_shape

    def forward(self, x):
        self.x = x
        self.z1 = np.dot(x, self.w1) + self.b1
        self.z1 = self.z1.astype(np.float64)
        self.a1 = sigmoid(self.z1)
        self.z2 = np.dot(self.a1, self.w2) + self.b2
        # convert to float32 to avoid overflow
        self.z2 = self.z2.astype(np.float32)
        self.a2 = sigmoid(self.z2)
        return self.a2

    def backward(self, y):
        self.y = y
        self.dz2 = self.a2 - self.y
        self.dw2 = np.dot(self.a1.T, self.dz2)
        self.db2 = np.sum(self.dz2, axis=0)
        self.dz1 = np.dot(self.dz2, self.w2.T) * self.a1 * (1 - self.a1)
        self.dw1 = np.dot(self.x.T, self.dz1)
        self.db1 = np.sum(self.dz1, axis=0)

    def update(self, lr):
        self.w1 = np.subtract(self.w1, lr * self.dw1)
        self.b1 = np.subtract(self.b1, lr * self.db1)
        self.w2 = np.subtract(self.w2, lr * self.dw2)
        self.b2 = np.subtract(self.b2, lr * self.db2)

    def predict(self, x):
        return self.forward(x)

# testear el modelo
model = Model(8, 10,3)

"""Con el fin de tener mas informacion incrementamos el x """

# expandir el valor x concatenando su cuadrado
x_exp = np.concatenate((x, x**2), axis=1)

for epoch in range(100):
    y_pred = model.forward(x_exp)
    loss = np.mean(np.square(y_pred - y_one))
    model.backward(y_one)
    model.update(0.01)
    print(loss)

# testear el modelo
y_pred = model.predict(x_exp[2])
print(y_pred, y_one[2])
arg = np.argmax(y_pred)
print(arg)

#realize table with the results comparing the predicted and the real values
y_pred = model.predict(x_exp)
y_pred = np.array([np.argmax(i) for i in y_pred])
y_pred = np.array([list(classes.keys())[i] for i in y_pred])
y_pred = pd.DataFrame(y_pred, columns=['Predicted'])
y_pred['Real'] = ty
y_pred